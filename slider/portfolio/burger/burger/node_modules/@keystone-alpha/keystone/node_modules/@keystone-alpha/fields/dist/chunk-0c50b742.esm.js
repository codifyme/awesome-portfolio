import _objectSpread from '@babel/runtime/helpers/esm/objectSpread';
import '@babel/runtime/helpers/esm/objectWithoutProperties';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import { countArrays, arrayToObject, captureSuspensePromises } from '@keystone-alpha/utils';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { jsx } from '@emotion/core';
import { Component, Fragment, Suspense, useCallback, useMemo, useState } from 'react';
import { FieldContainer, FieldLabel, FieldInput } from '@arch-ui/fields';
import _extends from '@babel/runtime/helpers/esm/extends';
import '@arch-ui/select';
import { gridSize } from '@arch-ui/theme';
import _taggedTemplateLiteral from '@babel/runtime/helpers/esm/taggedTemplateLiteral';
import { Mutation, Query } from 'react-apollo';
import gql from 'graphql-tag';
import { PersonIcon, LinkExternalIcon, PlusIcon } from '@arch-ui/icons';
import { LoadingButton, Button, IconButton } from '@arch-ui/button';
import Tooltip from '@arch-ui/tooltip';
import Drawer from '@arch-ui/drawer';
import { AutocompleteCaptor } from '@arch-ui/input';
import { LoadingIndicator } from '@arch-ui/loading';
import 'react-select';
import 'intersection-observer';
import { a as RelationshipSelect } from './chunk-ad892f45.esm.js';

const PageLoading = () => jsx("div", {
  css: {
    height: 200,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%'
  }
}, jsx(LoadingIndicator, {
  size: 12
}));

let Render = _ref => {
  let children = _ref.children;
  return children();
};

class CreateItemModal extends Component {
  constructor(_props) {
    super(_props);

    _defineProperty(this, "onCreate", async event => {
      // prevent form submission
      event.preventDefault(); // we have to stop propagation so that if this modal is inside another form
      // it won't submit the form above it
      // this will most likely happen when a CreateItemModal is nested inside
      // another CreateItemModal when creating an item in a relationship field
      // if you're thinking, why is this necessary, the modal is in a portal?
      // it's important to remember that react events
      // propagate through portals as if they aren't there

      event.stopPropagation();
      const _this$props = this.props,
            fields = _this$props.list.fields,
            createItem = _this$props.createItem,
            isLoading = _this$props.isLoading;
      if (isLoading) return;
      const _this$state = this.state,
            item = _this$state.item,
            validationErrors = _this$state.validationErrors,
            validationWarnings = _this$state.validationWarnings;

      if (countArrays(validationErrors)) {
        return;
      }

      const creatable = fields.filter(_ref2 => {
        let isPrimaryKey = _ref2.isPrimaryKey;
        return !isPrimaryKey;
      }).filter(_ref3 => {
        let maybeAccess = _ref3.maybeAccess;
        return !!maybeAccess.create;
      });
      const data = arrayToObject(creatable, 'path', field => field.serialize(item));

      if (!countArrays(validationWarnings)) {
        const errors = {};
        const warnings = {};
        await Promise.all(fields.map(_ref4 => {
          let validateInput = _ref4.validateInput,
              path = _ref4.path;

          const addFieldValidationError = (message, data) => {
            errors[path] = errors[path] || [];
            errors[path].push({
              message,
              data
            });
          };

          const addFieldValidationWarning = (message, data) => {
            warnings[path] = warnings[path] || [];
            warnings[path].push({
              message,
              data
            });
          };

          return validateInput({
            resolvedData: data,
            originalInput: item,
            addFieldValidationError,
            addFieldValidationWarning
          });
        }));

        if (countArrays(errors) + countArrays(warnings) > 0) {
          this.setState(() => ({
            validationErrors: errors,
            validationWarnings: warnings
          }));
          return;
        }
      }

      createItem({
        variables: {
          data
        }
      }).then(data => {
        this.props.onCreate(data);
        this.setState({
          item: this.props.list.getInitialItemData({})
        });
      });
    });

    _defineProperty(this, "onClose", () => {
      const isLoading = this.props.isLoading;
      if (isLoading) return;
      this.props.onClose();
    });

    _defineProperty(this, "onKeyDown", event => {
      if (event.defaultPrevented) return;

      switch (event.key) {
        case 'Escape':
          return this.onClose();
      }
    });

    _defineProperty(this, "formComponent", props => jsx("form", _extends({
      autoComplete: "off",
      onSubmit: this.onCreate
    }, props)));

    const list = _props.list,
          _props$prefillData = _props.prefillData,
          prefillData = _props$prefillData === void 0 ? {} : _props$prefillData;

    const _item = list.getInitialItemData({
      prefill: prefillData
    });

    const _validationErrors = {};
    const _validationWarnings = {};
    this.state = {
      item: _item,
      validationErrors: _validationErrors,
      validationWarnings: _validationWarnings
    };
  }

  render() {
    const _this$props2 = this.props,
          isLoading = _this$props2.isLoading,
          isOpen = _this$props2.isOpen,
          list = _this$props2.list;
    const _this$state2 = this.state,
          item = _this$state2.item,
          validationErrors = _this$state2.validationErrors,
          validationWarnings = _this$state2.validationWarnings;
    const hasWarnings = countArrays(validationWarnings);
    const hasErrors = countArrays(validationErrors);
    const cypressId = 'create-relationship-item-modal-submit-button';
    return jsx(Drawer, {
      closeOnBlanketClick: true,
      component: this.formComponent,
      isOpen: isOpen,
      onClose: this.onClose,
      heading: "Create ".concat(list.singular),
      onKeyDown: this.onKeyDown,
      slideInFrom: "right",
      footer: jsx(Fragment, null, jsx(LoadingButton, {
        appearance: hasWarnings && !hasErrors ? 'warning' : 'primary',
        id: cypressId,
        isDisabled: hasErrors,
        isLoading: isLoading,
        onClick: this.onUpdate,
        type: "submit"
      }, hasWarnings && !hasErrors ? 'Ignore Warnings and Create' : 'Create'), jsx(Button, {
        appearance: "warning",
        variant: "subtle",
        onClick: this.onClose
      }, "Cancel"))
    }, jsx("div", {
      css: {
        marginBottom: gridSize,
        marginTop: gridSize
      }
    }, jsx(Suspense, {
      fallback: jsx(PageLoading, null)
    }, jsx(AutocompleteCaptor, null), jsx(Render, null, () => {
      const creatable = list.fields.filter(_ref5 => {
        let isPrimaryKey = _ref5.isPrimaryKey;
        return !isPrimaryKey;
      }).filter(_ref6 => {
        let maybeAccess = _ref6.maybeAccess;
        return !!maybeAccess.create;
      });
      captureSuspensePromises(creatable.map(field => () => field.initFieldView()));
      return creatable.map((field, i) => {
        return jsx(Render, {
          key: field.path
        }, () => {
          let _field$adminMeta$read = field.adminMeta.readViews([field.views.Field]),
              _field$adminMeta$read2 = _slicedToArray(_field$adminMeta$read, 1),
              Field = _field$adminMeta$read2[0];

          let onChange = useCallback(value => {
            this.setState(_ref7 => {
              let item = _ref7.item;
              return {
                item: _objectSpread({}, item, {
                  [field.path]: value
                }),
                validationErrors: {},
                validationWarnings: {}
              };
            });
          }, []);
          return useMemo(() => jsx(Field, {
            autoFocus: !i,
            value: item[field.path],
            savedValue: item[field.path],
            field: field
            /* TODO: Permission query results */
            ,
            errors: validationErrors[field.path] || [],
            warnings: validationWarnings[field.path] || [],
            onChange: onChange,
            renderContext: "dialog"
          }), [i, item[field.path], field, onChange, validationErrors[field.path], validationWarnings[field.path]]);
        });
      });
    }))));
  }

}

class CreateItemModalWithMutation extends Component {
  render() {
    const list = this.props.list;
    return jsx(Mutation, {
      mutation: list.createMutation
    }, (createItem, _ref8) => {
      let loading = _ref8.loading;
      return jsx(CreateItemModal, _extends({
        createItem: createItem,
        isLoading: loading
      }, this.props));
    });
  }

}

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n        query User {\n          ", " {\n            _label_\n            id\n          }\n        }\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

const MAX_IDS_IN_FILTER = 100;

function SetAsCurrentUser(_ref) {
  let listKey = _ref.listKey,
      value = _ref.value,
      onAddUser = _ref.onAddUser,
      many = _ref.many;
  let path = 'authenticated' + listKey;
  return jsx(Query, {
    query: gql(_templateObject(), path)
  }, _ref2 => {
    let data = _ref2.data;

    if (data && data[path]) {
      let userId = data[path].id;

      if (value !== null && (many ? value.some(item => item.id === userId) : value.id === userId)) {
        return null;
      }

      let label = "".concat(many ? 'Add' : 'Set as', " ").concat(data[path]._label_);
      return jsx(Tooltip, {
        placement: "top",
        content: label
      }, ref => jsx(IconButton, {
        css: {
          marginLeft: gridSize
        },
        variant: "ghost",
        ref: ref,
        onClick: () => {
          onAddUser(data[path]);
        },
        icon: PersonIcon,
        "aria-label": label
      }));
    }

    return null;
  });
}

function LinkToRelatedItems(_ref3) {
  let field = _ref3.field,
      value = _ref3.value;
  const _field$config = field.config,
        many = _field$config.many,
        ref = _field$config.ref;
  const _field$adminMeta = field.adminMeta,
        adminPath = _field$adminMeta.adminPath,
        getListByKey = _field$adminMeta.getListByKey;
  const refList = getListByKey(ref);
  let isDisabled = false;
  let label;
  let link = "".concat(adminPath, "/").concat(refList.path);

  if (many) {
    label = 'View List of Related Items';

    if (!value.length) {
      isDisabled = true;
    } // What happens when there are 10,000 ids? The URL would be too
    // big, so we arbitrarily limit it to the first 100


    link = "".concat(link, "?!id_in=\"").concat(value.slice(0, MAX_IDS_IN_FILTER).map(_ref4 => {
      let id = _ref4.id;
      return id;
    }).join(','), "\"");
  } else {
    label = 'View Item Details';

    if (!value) {
      isDisabled = true;
    } else {
      link = "".concat(link, "/").concat(value.id);
    }
  }

  return jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => jsx(IconButton, {
    ref: ref,
    icon: LinkExternalIcon,
    "aria-label": label,
    variant: "ghost",
    css: {
      marginLeft: gridSize
    },
    target: "_blank",
    to: link,
    isDisabled: isDisabled
  }));
}

function CreateAndAddItem(_ref5) {
  let field = _ref5.field,
      item = _ref5.item,
      list = _ref5.list,
      _onCreate = _ref5.onCreate;
  let relatedList = field.adminMeta.getListByKey(field.config.ref);

  let _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  let label = "Create and add ".concat(relatedList.singular);
  let prefillData;

  if (item && item.id) {
    prefillData = relatedList.fields // Find relationships on the refList which have a back link to this
    // Relationship field
    .filter(relatedField => relatedField.type === 'Relationship' && relatedField.config.ref === list.key && relatedField.config.refFieldPath === field.path) // And convert it into an object of data to prefill the form with
    .reduce((memo, prefillField) => {
      const prefill = {
        _label_: item._label_ || '<link to parent>',
        id: item.id
      };
      return _objectSpread({}, memo, {
        [prefillField.path]: prefillField.config.many ? [prefill] : prefill
      });
    }, {});
  }

  return jsx(Fragment, null, jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => jsx(IconButton, {
    ref: ref,
    onClick: () => {
      setIsOpen(true);
    },
    icon: PlusIcon,
    "aria-label": label,
    variant: "ghost",
    css: {
      marginLeft: gridSize
    }
  })), jsx(CreateItemModalWithMutation, {
    isOpen: isOpen,
    list: relatedList,
    prefillData: prefillData,
    onClose: () => {
      setIsOpen(false);
    },
    onCreate: _ref6 => {
      let data = _ref6.data;
      setIsOpen(false);
      console.log(data);

      _onCreate(data[relatedList.gqlNames.createMutationName]);
    }
  }));
}

class RelationshipField extends Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onChange", option => {
      const _this$props = this.props,
            field = _this$props.field,
            onChange = _this$props.onChange;
      const many = field.config.many;

      if (many) {
        onChange(option.map(i => i.value));
      } else {
        onChange(option ? option.value : null);
      }
    });
  }

  render() {
    const _this$props2 = this.props,
          autoFocus = _this$props2.autoFocus,
          field = _this$props2.field,
          value = _this$props2.value,
          renderContext = _this$props2.renderContext,
          errors = _this$props2.errors,
          onChange = _this$props2.onChange,
          item = _this$props2.item,
          list = _this$props2.list;
    const _field$config2 = field.config,
          many = _field$config2.many,
          ref = _field$config2.ref;
    const authStrategy = field.adminMeta.authStrategy;
    const htmlID = "ks-input-".concat(field.path);
    return jsx(FieldContainer, null, jsx(FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), jsx(FieldInput, null, jsx("div", {
      css: {
        flex: 1
      }
    }, jsx(RelationshipSelect, {
      autoFocus: autoFocus,
      isMulti: many,
      field: field,
      value: value,
      errors: errors,
      renderContext: renderContext,
      htmlID: htmlID,
      onChange: this.onChange
    })), jsx(CreateAndAddItem, {
      onCreate: item => {
        onChange(many ? (value || []).concat(item) : item);
      },
      field: field,
      item: item,
      list: list
    }), authStrategy && ref === authStrategy.listKey && jsx(SetAsCurrentUser, {
      many: many,
      onAddUser: user => {
        onChange(many ? (value || []).concat(user) : user);
      },
      value: value,
      listKey: authStrategy.listKey
    }), jsx(LinkToRelatedItems, {
      field: field,
      value: value
    })));
  }

}

export default RelationshipField;
