import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import { jsx } from '@emotion/core';
import { useState } from 'react';
import { FieldContainer, FieldLabel, FieldInput } from '@arch-ui/fields';
import _extends from '@babel/runtime/helpers/esm/extends';
import Select from '@arch-ui/select';
import { useToasts } from 'react-toast-notifications';
import { GoogleApiWrapper, Map as Map$1, Marker } from 'google-maps-react';

const LocationField = _ref => {
  let field = _ref.field,
      serverValue = _ref.value,
      errors = _ref.errors,
      onChange = _ref.onChange,
      google = _ref.google,
      renderContext = _ref.renderContext;

  const _ref2 = serverValue || {},
        googlePlaceID = _ref2.googlePlaceID,
        formattedAddress = _ref2.formattedAddress,
        lat = _ref2.lat,
        lng = _ref2.lng;

  const htmlID = "ks-input-".concat(field.path);
  const autocompleteService = new google.maps.places.AutocompleteService();
  const geocoder = new google.maps.Geocoder();

  const _useToasts = useToasts(),
        addToast = _useToasts.addToast;

  const _useState = useState(googlePlaceID ? {
    label: formattedAddress,
    value: googlePlaceID
  } : null),
        _useState2 = _slicedToArray(_useState, 2),
        inputValue = _useState2[0],
        setInputValue = _useState2[1];

  const _useState3 = useState(lat && lng ? {
    lat,
    lng
  } : null),
        _useState4 = _slicedToArray(_useState3, 2),
        marker = _useState4[0],
        setMarker = _useState4[1];

  const handleOptionChange = option => {
    if (!option) {
      onChange(null);
      setMarker(null);
      setInputValue(null);
      return;
    }

    const placeId = option.value;
    geocoder.geocode({
      placeId
    }, (results, status) => {
      if (status === 'OK') {
        if (results[0]) {
          const _results$ = results[0],
                formatted_address = _results$.formatted_address,
                _results$$geometry$lo = _results$.geometry.location,
                lat = _results$$geometry$lo.lat,
                lng = _results$$geometry$lo.lng;
          setInputValue({
            label: formatted_address,
            value: placeId
          });
          setMarker({
            lat: lat(),
            lng: lng()
          });
          onChange(placeId);
        }
      } else {
        addToast('Could not find the provided location.', {
          appearance: 'error',
          autoDismiss: true
        });
      }
    });
  };

  const loadOptions = inputValue => new Promise(resolve => {
    autocompleteService.getPlacePredictions({
      input: inputValue
    }, results => {
      if (results) {
        resolve(results.map(_ref3 => {
          let description = _ref3.description,
              place_id = _ref3.place_id;
          return {
            label: description,
            value: place_id
          };
        }));
      }

      resolve(null);
    });
  });

  const selectProps = renderContext === 'dialog' ? {
    menuPortalTarget: document.body,
    menuShouldBlockScroll: true
  } : null;
  return jsx(FieldContainer, null, jsx(FieldLabel, {
    htmlFor: htmlID,
    field: field,
    errors: errors
  }), jsx(FieldInput, {
    css: {
      flexDirection: 'column'
    }
  }, jsx(Select, _extends({
    isAsync: true,
    isClearable: true,
    cacheOptions: true,
    placeholder: "Search for a location ...",
    value: inputValue,
    onChange: handleOptionChange,
    loadOptions: loadOptions,
    id: "react-select-".concat(htmlID),
    inputId: htmlID,
    instanceId: htmlID,
    css: {
      width: '100%'
    }
  }, selectProps)), marker && jsx("div", {
    css: {
      position: 'relative',
      height: '14rem',
      marginTop: '1rem'
    }
  }, jsx(Map$1, {
    google: google,
    initialCenter: marker,
    center: marker,
    zoom: 16
  }, jsx(Marker, {
    position: marker
  })))));
};

var Field = GoogleApiWrapper(props => ({
  apiKey: props.field.config.googleMapsKey
}))(LocationField);
export default Field;
