"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _objectSpread = _interopDefault(require("@babel/runtime/helpers/objectSpread")), _slicedToArray = _interopDefault(require("@babel/runtime/helpers/slicedToArray")), pLazy = _interopDefault(require("p-lazy")), pReflect = _interopDefault(require("p-reflect")), isPromise = _interopDefault(require("p-is-promise"));

const noop = x => x, identity = noop, getType = thing => Object.prototype.toString.call(thing).replace(/\[object (.*)\]/, "$1"), escapeRegExp = str => (str || "").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), mapKeys = (obj, func) => Object.entries(obj).reduce((acc, _ref) => {
  let _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
  return _objectSpread({}, acc, {
    [key]: func(value, key, obj)
  });
}, {}), mapKeyNames = (obj, func) => Object.entries(obj).reduce((acc, _ref3) => {
  let _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], value = _ref4[1];
  return _objectSpread({}, acc, {
    [func(key, value, obj)]: value
  });
}, {}), resolveAllKeys = obj => {
  const returnValue = {}, errors = {}, allPromises = Object.keys(obj).map(key => pReflect(obj[key]).then(val => (val.isFulfilled ? returnValue[key] = val.value : val.isRejected && (errors[key] = val.reason), 
  val)));
  return Promise.all(allPromises).then(results => {
    if (Object.keys(errors).length) {
      const firstError = results.find(_ref5 => {
        return _ref5.isRejected;
      }).reason, error = new Error(firstError.message || firstError.toString());
      throw error.errors = errors, error;
    }
    return returnValue;
  });
}, unique = arr => [ ...new Set(arr) ], intersection = (array1, array2) => unique(array1.filter(value => array2.includes(value))), pick = (obj, keys) => keys.reduce((acc, key) => key in obj ? _objectSpread({}, acc, {
  [key]: obj[key]
}) : acc, {}), omitBy = (obj, func) => pick(obj, Object.keys(obj).filter(value => !func(value))), omit = (obj, keys) => omitBy(obj, value => keys.includes(value)), objMerge = objs => objs.reduce((acc, obj) => _objectSpread({}, acc, obj), {}), defaultObj = (keys, val) => keys.reduce((acc, key) => _objectSpread({}, acc, {
  [key]: val
}), {}), filterValues = (obj, predicate) => Object.entries(obj).reduce((acc, _ref6) => {
  let _ref7 = _slicedToArray(_ref6, 2), key = _ref7[0], value = _ref7[1];
  return predicate(value) ? _objectSpread({}, acc, {
    [key]: value
  }) : acc;
}, {}), arrayToObject = function(objs, keyedBy) {
  let mapFn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i => i;
  return objs.reduce((acc, obj) => _objectSpread({}, acc, {
    [obj[keyedBy]]: mapFn(obj)
  }), {});
}, flatten = arr => Array.prototype.concat(...arr), flatMap = function(arr) {
  let fn = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : identity;
  return flatten(arr.map(fn));
}, zipObj = obj => Object.values(obj)[0].map((_, i) => Object.keys(obj).reduce((acc, k) => _objectSpread({}, acc, {
  [k]: obj[k][i]
}), {})), compose = fns => o => fns.reduce((acc, fn) => fn(acc), o), mergeWhereClause = (queryArgs, whereClauseToMergeIn) => {
  if ("Object" !== getType(whereClauseToMergeIn) || 0 === Object.keys(whereClauseToMergeIn).length) return queryArgs;
  const mergedQueryArgs = queryArgs.where && Object.keys(queryArgs.where).length > 0 ? {
    AND: [ queryArgs.where, whereClauseToMergeIn ]
  } : whereClauseToMergeIn;
  return _objectSpread({}, queryArgs, {
    where: mergedQueryArgs
  });
}, createLazyDeferred = () => {
  let state, resolvedWith, rejectedWith, resolveCallback, rejectCallback;
  return {
    promise: new pLazy((resolve, reject) => {
      "resolved" === state ? resolve(resolvedWith) : "rejected" === state ? reject(rejectedWith) : (resolveCallback = resolve, 
      rejectCallback = reject);
    }),
    resolve: val => {
      resolveCallback ? resolveCallback(val) : (resolvedWith = val, state = "resolved");
    },
    reject: error => {
      rejectCallback ? rejectCallback(error) : (rejectedWith = error, state = "rejected");
    }
  };
}, captureSuspensePromises = executors => {
  const values = [], promises = executors.map(executor => {
    try {
      values.push(executor());
    } catch (loadingPromiseOrError) {
      if (!isPromise(loadingPromiseOrError)) throw loadingPromiseOrError;
      return loadingPromiseOrError;
    }
  }).filter(Boolean);
  if (promises.length) throw Promise.all(promises);
  return values;
}, countArrays = obj => Object.values(obj).reduce((total, items) => total + (items ? items.length : 0), 0);

exports.arrayToObject = arrayToObject, exports.captureSuspensePromises = captureSuspensePromises, 
exports.compose = compose, exports.countArrays = countArrays, exports.createLazyDeferred = createLazyDeferred, 
exports.defaultObj = defaultObj, exports.escapeRegExp = escapeRegExp, exports.filterValues = filterValues, 
exports.flatMap = flatMap, exports.flatten = flatten, exports.getType = getType, 
exports.identity = identity, exports.intersection = intersection, exports.mapKeyNames = mapKeyNames, 
exports.mapKeys = mapKeys, exports.mergeWhereClause = mergeWhereClause, exports.noop = noop, 
exports.objMerge = objMerge, exports.omit = omit, exports.omitBy = omitBy, exports.pick = pick, 
exports.resolveAllKeys = resolveAllKeys, exports.unique = unique, exports.zipObj = zipObj;
