import _objectSpread from '@babel/runtime/helpers/esm/objectSpread';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import pLazy from 'p-lazy';
import pReflect from 'p-reflect';
import isPromise from 'p-is-promise';

const noop = x => x;
const identity = noop;
const getType = thing => Object.prototype.toString.call(thing).replace(/\[object (.*)\]/, '$1');
const escapeRegExp = str => (str || '').replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&'); // { key: value, ... } => { key: mapFn(value, key), ... }

const mapKeys = (obj, func) => Object.entries(obj).reduce((acc, _ref) => {
  let _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[0],
      value = _ref2[1];

  return _objectSpread({}, acc, {
    [key]: func(value, key, obj)
  });
}, {}); // { key: value, ... } => { mapFn(key, value): value, ... }

const mapKeyNames = (obj, func) => Object.entries(obj).reduce((acc, _ref3) => {
  let _ref4 = _slicedToArray(_ref3, 2),
      key = _ref4[0],
      value = _ref4[1];

  return _objectSpread({}, acc, {
    [func(key, value, obj)]: value
  });
}, {});
const resolveAllKeys = obj => {
  const returnValue = {};
  const errors = {};
  const allPromises = Object.keys(obj).map(key => pReflect(obj[key]).then(val => {
    if (val.isFulfilled) {
      returnValue[key] = val.value;
    } else if (val.isRejected) {
      errors[key] = val.reason;
    }

    return val;
  }));
  return Promise.all(allPromises).then(results => {
    // If there are any errors, we want to surface them in the same shape as the
    // input object
    if (Object.keys(errors).length) {
      const firstError = results.find((_ref5) => {
        let isRejected = _ref5.isRejected;
        return isRejected;
      }).reason; // Use the first error as the message so it's at least meaningful

      const error = new Error(firstError.message || firstError.toString());
      error.errors = errors;
      throw error;
    }

    return returnValue;
  });
};
const unique = arr => [...new Set(arr)];
const intersection = (array1, array2) => unique(array1.filter(value => array2.includes(value)));
const pick = (obj, keys) => keys.reduce((acc, key) => key in obj ? _objectSpread({}, acc, {
  [key]: obj[key]
}) : acc, {});
const omitBy = (obj, func) => pick(obj, Object.keys(obj).filter(value => !func(value)));
const omit = (obj, keys) => omitBy(obj, value => keys.includes(value)); // [{ k1: v1, k2: v2, ...}, { k3: v3, k4: v4, ...}, ...] => { k1: v1, k2: v2, k3: v3, k4, v4, ... }
// Gives priority to the objects which appear later in the list

const objMerge = objs => objs.reduce((acc, obj) => _objectSpread({}, acc, obj), {}); // [x, y, z] => { x: val, y: val, z: val}

const defaultObj = (keys, val) => keys.reduce((acc, key) => _objectSpread({}, acc, {
  [key]: val
}), {});
const filterValues = (obj, predicate) => Object.entries(obj).reduce((acc, _ref6) => {
  let _ref7 = _slicedToArray(_ref6, 2),
      key = _ref7[0],
      value = _ref7[1];

  return predicate(value) ? _objectSpread({}, acc, {
    [key]: value
  }) : acc;
}, {}); // [x, y, z] => { x[keyedBy]: mapFn(x), ... }
// [{ name: 'a', animal: 'cat' },
//  { name: 'b', animal: 'dog' },
//  { name: 'c', animal: 'cat' },
//  { name: 'd', animal: 'dog' }]
// arraytoObject(obj, 'name', o => o.animal) =>
// { a: 'cat',
//   b: 'dog',
//   c: 'cat',
//   d: 'dog'}

const arrayToObject = function arrayToObject(objs, keyedBy) {
  let mapFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : i => i;
  return objs.reduce((acc, obj) => _objectSpread({}, acc, {
    [obj[keyedBy]]: mapFn(obj)
  }), {});
}; // [[1, 2, 3], [4, 5], 6, [[7, 8], [9, 10]]] => [1, 2, 3, 4, 5, 6, [7, 8], [9, 10]]

const flatten = arr => Array.prototype.concat(...arr); // flatMap([{ vals: [2, 2] }, { vals: [3] }], x => x.vals) => [2, 2, 3]

const flatMap = function flatMap(arr) {
  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  return flatten(arr.map(fn));
}; // { foo: [1, 2, 3], bar: [4, 5, 6]} => [{ foo: 1, bar: 4}, { foo: 2, bar: 5}, { foo: 3, bar: 6 }]

const zipObj = obj => Object.values(obj)[0].map((_, i) => Object.keys(obj).reduce((acc, k) => _objectSpread({}, acc, {
  [k]: obj[k][i]
}), {})); // compose([f, g, h])(o) = h(g(f(o)))

const compose = fns => o => fns.reduce((acc, fn) => fn(acc), o);
const mergeWhereClause = (queryArgs, whereClauseToMergeIn) => {
  if (getType(whereClauseToMergeIn) !== 'Object' || Object.keys(whereClauseToMergeIn).length === 0) {
    return queryArgs;
  }

  const mergedQueryArgs = queryArgs.where && Object.keys(queryArgs.where).length > 0 ? {
    AND: [queryArgs.where, whereClauseToMergeIn]
  } : whereClauseToMergeIn;
  return _objectSpread({}, queryArgs, {
    where: mergedQueryArgs
  });
};
const createLazyDeferred = () => {
  let state;
  let resolvedWith;
  let rejectedWith;
  let resolveCallback;
  let rejectCallback;
  const promise = new pLazy((resolve, reject) => {
    if (state === 'resolved') {
      resolve(resolvedWith);
    } else if (state === 'rejected') {
      reject(rejectedWith);
    } else {
      resolveCallback = resolve;
      rejectCallback = reject;
    }
  });
  return {
    promise,
    resolve: val => {
      if (resolveCallback) {
        resolveCallback(val);
      } else {
        resolvedWith = val;
        state = 'resolved';
      }
    },
    reject: error => {
      if (rejectCallback) {
        rejectCallback(error);
      } else {
        rejectedWith = error;
        state = 'rejected';
      }
    }
  };
};
/**
 * Given an array of functions which may throw a Promise when executed, we want
 * to ensure all functions are executed, reducing any thrown Promises to a
 * single Promise, which is itself rethrown.
 * If no Promises are thrown, this is the equivalent of a .map
 */

const captureSuspensePromises = executors => {
  const values = [];
  const promises = executors.map(executor => {
    try {
      values.push(executor());
    } catch (loadingPromiseOrError) {
      // An actual error was thrown, so we want to bubble that up
      if (!isPromise(loadingPromiseOrError)) {
        throw loadingPromiseOrError;
      } // Return a Suspense promise


      return loadingPromiseOrError;
    }
  }).filter(Boolean);

  if (promises.length) {
    // All the suspense promises are reduced to a single promise then rethrown
    throw Promise.all(promises);
  }

  return values;
}; //ruturns the length of all arrays in obj
// { a: [1, 2], b: [1, 2, 3] } => 5

const countArrays = obj => Object.values(obj).reduce((total, items) => total + (items ? items.length : 0), 0);

export { arrayToObject, captureSuspensePromises, compose, countArrays, createLazyDeferred, defaultObj, escapeRegExp, filterValues, flatMap, flatten, getType, identity, intersection, mapKeyNames, mapKeys, mergeWhereClause, noop, objMerge, omit, omitBy, pick, resolveAllKeys, unique, zipObj };
