import _objectSpread from '@babel/runtime/helpers/esm/objectSpread';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import { jsx } from '@emotion/core';
import { forwardRef, useMemo, useRef, useState, useEffect } from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import Select from '@arch-ui/select';
import _taggedTemplateLiteral from '@babel/runtime/helpers/esm/taggedTemplateLiteral';
import { Query } from 'react-apollo';
import gql from 'graphql-tag';
import { components } from 'react-select';
import 'intersection-observer';

function _templateObject2() {
  const data = _taggedTemplateLiteral(["query RelationshipSelect($search: String!, $skip: Int!) {", "", "}"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  const data = _taggedTemplateLiteral(["query RelationshipSelectMore($search: String!, $skip: Int!) {", "}"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function useIntersectionObserver(cb, ref) {
  useEffect(() => {
    let observer = new IntersectionObserver(cb, {});
    let node = ref.current;

    if (node !== null) {
      observer.observe(node);
      return () => observer.unobserve(node);
    }
  });
}

const initalItemsToLoad = 10;
const subsequentItemsToLoad = 50; // to use hooks in render props

const Relationship = forwardRef((_ref, ref) => {
  let data = _ref.data,
      loading = _ref.loading,
      value = _ref.value,
      refList = _ref.refList,
      canRead = _ref.canRead,
      isMulti = _ref.isMulti,
      search = _ref.search,
      autoFocus = _ref.autoFocus,
      serverErrors = _ref.serverErrors,
      onChange = _ref.onChange,
      htmlID = _ref.htmlID,
      setSearch = _ref.setSearch,
      selectProps = _ref.selectProps,
      fetchMore = _ref.fetchMore;
  const options = data && data[refList.gqlNames.listQueryName] ? data[refList.gqlNames.listQueryName].map(val => ({
    value: val,
    label: val._label_
  })) : [];
  const serverError = serverErrors && serverErrors.find(error => error instanceof Error && error.name === 'AccessDeniedError');
  let currentValue = null;

  const getOption = value => typeof value === 'string' ? options.find(opt => opt.value.id === value) || {
    label: value,
    value: value
  } : {
    label: value._label_,
    value: value
  };

  if (value !== null && canRead) {
    if (isMulti) {
      currentValue = (Array.isArray(value) ? value : []).map(getOption);
    } else if (value) {
      currentValue = getOption(value);
    }
  }

  const count = data && data[refList.gqlNames.listQueryMetaName] ? data[refList.gqlNames.listQueryMetaName].count : 0;
  const selectComponents = useMemo(() => ({
    MenuList: _ref2 => {
      let children = _ref2.children,
          props = _objectWithoutProperties(_ref2, ["children"]);

      const loadingRef = useRef(null);
      useIntersectionObserver(_ref3 => {
        let _ref4 = _slicedToArray(_ref3, 1),
            isIntersecting = _ref4[0].isIntersecting;

        if (!props.isLoading && isIntersecting && props.options.length < count) {
          fetchMore({
            query: gql(_templateObject(), refList.buildQuery(refList.gqlNames.listQueryName, "(first: ".concat(subsequentItemsToLoad, ", search: $search, skip: $skip)"))),
            variables: {
              search,
              skip: props.options.length
            },
            updateQuery: (prev, _ref5) => {
              let fetchMoreResult = _ref5.fetchMoreResult;
              if (!fetchMoreResult) return prev;
              return _objectSpread({}, prev, {
                [refList.gqlNames.listQueryName]: [...prev[refList.gqlNames.listQueryName], ...fetchMoreResult[refList.gqlNames.listQueryName]]
              });
            }
          });
        }
      }, loadingRef);
      return jsx(components.MenuList, props, children, jsx("div", {
        css: {
          textAlign: 'center'
        },
        ref: loadingRef
      }, props.options.length < count && jsx("span", {
        css: {
          padding: 8
        }
      }, "Loading...")));
    }
  }), [count, refList.gqlNames.listQueryName]);
  return jsx(Select // this is necessary because react-select passes a second argument to onInputChange
  // and useState setters log a warning if a second argument is passed
  , _extends({
    onInputChange: val => setSearch(val),
    isLoading: loading,
    autoFocus: autoFocus,
    isMulti: isMulti,
    components: selectComponents,
    getOptionValue: option => option.value.id,
    value: currentValue,
    placeholder: // $FlowFixMe
    canRead ? undefined : serverError && serverError.message,
    options: options,
    onChange: onChange,
    id: "react-select-".concat(htmlID),
    isClearable: true,
    instanceId: htmlID,
    inputId: htmlID,
    innerRef: ref,
    menuPortalTarget: document.body
  }, selectProps));
});

const RelationshipSelect = _ref6 => {
  let innerRef = _ref6.innerRef,
      autoFocus = _ref6.autoFocus,
      field = _ref6.field,
      serverErrors = _ref6.errors,
      renderContext = _ref6.renderContext,
      htmlID = _ref6.htmlID,
      onChange = _ref6.onChange,
      isMulti = _ref6.isMulti,
      value = _ref6.value;

  const _useState = useState(''),
        _useState2 = _slicedToArray(_useState, 2),
        search = _useState2[0],
        setSearch = _useState2[1];

  const refList = field.getRefList();
  const query = gql(_templateObject2(), refList.buildQuery(refList.gqlNames.listQueryName, "(first: ".concat(initalItemsToLoad, ", search: $search, skip: $skip)")), refList.countQuery("(search: $search)"));
  const canRead = !serverErrors || serverErrors.every(error => !(error instanceof Error && error.name === 'AccessDeniedError'));
  const selectProps = renderContext === 'dialog' ? {
    menuShouldBlockScroll: true
  } : null;
  return jsx(Query, {
    query: query,
    variables: {
      search,
      skip: 0
    }
  }, _ref7 => {
    let data = _ref7.data,
        error = _ref7.error,
        loading = _ref7.loading,
        fetchMore = _ref7.fetchMore; // TODO: better error UI
    // TODO: Handle permission errors
    // (ie; user has permission to read this relationship field, but
    // not the related list, or some items on the list)

    if (error) console.log('ERROR!!!', error);
    if (error) return 'Error';
    return jsx(Relationship, {
      data,
      loading,
      value,
      refList,
      canRead,
      isMulti,
      search,
      autoFocus,
      serverErrors,
      onChange,
      htmlID,
      setSearch,
      selectProps,
      fetchMore,
      ref: innerRef
    });
  });
};

export { RelationshipSelect as a };
